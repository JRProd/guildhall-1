Setting up Uniform Buffers
======

1. Create desired top level code
2. Stub out methods and classes you see.
3. Start with getting Orthographic Projection Working
   1. Switch to [./shader/ubo.hlsl](./shader/ubo.hlsl), which uses a UniformBuffer
   2. Update method on Camera to set ortho to save off the information
   3. Have RenderContext::BeginCamera now tell the Camera to update its UBO...
   4. ...and Bind it (stub needed methods/members as you go)
      - Implement `RenderContext::BindUniformBuffer`, add needed members and methods
   5. Implement `UniformBuffer`
   6. Implment `RenderBuffer` - which is the bulk of the D3D11 work
   7. *Note: I am giving you a lot of this code - take the time to understand it!*
4. Get VertexBuffers working
   1. Switch to [./shader/vbo.hlsl](./shader/vbo.hlsl), which uses a UniformBuffer
   2. Stub out `RenderContext::DrawVertexArrays`, which will stub out `VertexBuffer`
   3. Implement `RenderContext::BindVertexStream`, add members/methods to `VertexBuffer` as needed
   4. Implement `VertexBuffer`
   5. Test
5. Implement the `FRAME CONSTANTS` uniform buffer so your shaders can use time (excercise for reader)


## Uniform Buffers
- **Uniform Buffers** (aka: **Constant Buffers**) are ways to feed information to the shader that is _constant__ for the entire draw call.  

  - Can map up to 64KB of data
  - Up to 15 buffers can be bounds in D3D11
    - We usually end up using about 4 or 5 total for projects at Guildhall.

## Vertex Buffers
- Normal creation
- Stream Slots
- Instanced Rendering
- Vertex Layout
- `buffer_attribute_t` implementation;  (if time)


## Orthographic Projection as a Matrix (if time) 



## Rendering Machine
So, to give a little look under the hood - this is a psuedo-code software 
rasterizer to help give an idea what the D3D11 context is doing and how
all the pieces fit together.  

- (Resource Limits)[https://docs.microsoft.com/en-us/windows/desktop/direct3d11/overviews-direct3d-11-resources-limits]


```cpp

// All the information needed for a draw call to work?
struct render_context_t 
{
	void const *vertexStream; 
	size_t vertexStride; 

	void const* ubos[15]; 					// b#
	TextureView const* textureViews[128];	// t#
	Sampler const* samplers[16]; 			// s#

	Image *output; 

	size_t vertexOutputSize; 					// generated by the shader
	void (*vertexFunc)( void *out, void *in, 
		void const **ubos, 				// d3d11 can have 15 (16 total, but one is reserved)
		TextureView const *views, 		// d3d11 can have 128 of these
		Sampler const *samplers );      // d3d11 can have 16 of these

	size_t fragmentInputSize; 					// generated by the shade;r 
	rgba (*fragFunc)( void *in ); 

}

void Draw( render_context_t *ctx, uint vertCount )
{
	// first, figure out our vertex stream
	byte_t const *vertIter = (byte_t*)vertexStream; 

	// assuming primitives are triangles, we need three outputs; 
	byte_t *primitive = byte_t[vertexOutputSize * 3]; 
	for (uint i = 0U;  i < vertCount; ++i) {
		uint offset = i % 3;

		// notice, I never tell them how many are bound
		// the shader just will try to use them, if I forget
		// to bind them, we get undefined behaviour (usually a crash
		// or blackness) 
		ctx->vertexFunc( 
			primitive + (offset * vertexOutputSize), // space for the output
			vertIter, 								 // the input vert
			ctx->ubos, 
			ctx->textureViews, 
			ctx->samplers ); 
		vertIter += ctx->vertexStride; 


		if (i == 2) {
			// we have a full triangle; 
			// Raster stage then gives us the fragment info 
			// based on which pixels were affected. 
			foreach (fragment in Triangle(primitive)) {
				rgba color = ctx->fragmentFunc( fragment ); 

				// blend rules would go here. 
				ctx->output->SetPixel( fragment.pixelXY, color ); 
			}
		} 
	}

	// done
}
```